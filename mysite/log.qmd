---
title: "Drawing on the Logarithmic Scale"
format:
  html:
    minimal: true
    code-fold: false
    code-summary: "N.A."
    echo: true
    self-contained: false
    smooth-scroll: true
jupyter: python3
execute:
  cache: true
---
<script>
document.addEventListener('contextmenu', event => event.preventDefault());
</script>
<script type="text/javascript" charset="UTF-8"
 src="jsfiles/jsxgraph/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet" type="text/css" href="jsfiles/jsxgraph/distrib/jsxgraph.css" />

<script>var SCITTLE_NREPL_WEBSOCKET_PORT = 1340;</script>
<script src="jsfiles/scittle/dist/scittle.js" type="application/javascript"></script>
<script src="jsfiles/scittle/dist/scittle.nrepl.js" type="application/javascript"></script>
<script src="jsfiles/blockly/blockly_compressed.js"></script>
<script src="jsfiles/blockly/msg/en.js"></script>
<script src="jsfiles/twotiles/twotiles_core.js"></script>

<link rel="stylesheet" type="text/css" href="jsfiles/rigsomelight.com/css/syntax.css">

<link rel="stylesheet" type="text/css" href="jsfiles/rigsomelight.com/assets/bootstrap/css/bootstrap.css">

<link rel="stylesheet" type="text/css" href="jsfiles/rigsomelight.com/assets/css/style.css">

<link rel="stylesheet" type="text/css" href="jsfiles/rigsomelight.com/assets/inline-edit/css/style.css">

<link rel="stylesheet" type="text/css" href="jsfiles/log.css">


<script>
var parse = scittle.core.eval_string(twotiles.parse_clj);
Blockly.defineBlocksWithJsonArray(twotiles.blocks);
</script>

<script>
var cleandiv = (divid) => {
const el = document.getElementById(divid);
while (el.firstChild) el.removeChild(el.firstChild);
}
var brenderT = (code,divid, bTrash) => {
cleandiv(divid);
let ws = Blockly.inject(divid,
{"sounds": false,
"scrollbars": false,
"trashcan": bTrash});

Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.utils.xml.textToDom(parse(code)), ws);

return ws;
}

var brender = (code,divid) => brenderT(code,divid, false)
</script>

<script>var statejs = {};</script>

<script>
const delay = ms => new Promise(res => setTimeout(res, ms));
</script>

::: {.hidden}
```{python}
#|code-fold: true
#|code-summary: "Code Preamble"

import sympy
from sympy import symbols, diff, ln
from sympy.codegen.cfunctions import log2
import functools
import matplotlib.pyplot as plt

x0=symbols("x0")
x1=symbols("x1")

def call(f, x):
    return f(x)

def mapv(a, b):
    return list(map(a, map(lambda x: 1.0 * x, b)))

class PipeAsCall(object):
    def __init__(self, func):
        self.func = func
    def __or__(self, other):
        return self.func(other)
    def __call__(self, x):
        return self.func(x)

def partial(*args):
    return PipeAsCall(
        functools.partial(*args))

def D(f):
  var = symbols("var")
  return PipeAsCall(sympy.lambdify([var], diff(f(var), var), "sympy"))

def rnd(expr):
     return expr.xreplace({n: round(n, 3) for n in expr.atoms(sympy.Number)})

def plot(f, x):
    plt.plot(x, mapv(f, x), "o")
```
:::

::: {.hidden}
```{python}
#| output: asis

import numpy as np
import json
import inspect

# https://muted.io/note-frequencies/
data = np.genfromtxt('notes.txt', delimiter='\t', dtype=str)
row_names = data[:, 0].tolist()
numerical_data = np.matrix.transpose(data[:, 1:]).astype(float).tolist()
               
print("<script>")
print("statejs['notenames']= ")
print(json.dumps(row_names))
print("statejs['frequencies']= ")

nofreq = [item
    for subl in
      [list(map(lambda n,f: [n, idx, f], row_names, fs))
        for idx, fs in enumerate(numerical_data)]
   for item in subl]


print(json.dumps([[nf[0] + str(nf[1]), nf[2]] for nf in nofreq if not nf[0].endswith("s")]))
print("</script>")

# instead of using the plain js
# print("<script src='jsfiles/notes.js'></script>")
# we load the respective Scittle code

print("<script>")
with open('notes.cljs', 'r') as file:
    data = file.read().replace('\n', '')
print("scittle.core.eval_string('", data, "')")
print("</script>")
```
:::

<!--
> The Pythagoreans have shown that the pitch of a tone depends on the length of a cord. This was the first successful reduction of quality to quantity and therefore the beginning of science.  
> - Arthur Koestler, the Sleepwalkers
-->

<details>
<summary id="1">1</summary>
<div id="divnotes2" class="jxgbox" style="height:300px;"></div>
<script>statejs.notes.main("divnotes2");</script>

<span onClick=statejs.notes.main('divnotes2') style="color:blue">A</span>
<span onClick="statejs.notes.anim1()" style="color:blue">B</span>
<span onClick="statejs.notes.anim2()" style="color:blue">C</span>
<span onClick="statejs.notes.anim3()" style="color:blue">D</span>
<span onClick="statejs.notes.anim5()" style="color:blue">E</span>
<span onClick="statejs.notes.anim6()" style="color:blue">F</span>

<div class="desc" id="divnotes2_t">
Sometimes, you need to start with the basics. I am sure you all have your own ways to do graphs. So you don't really need this, but I think my way has its own value. In a minute, I will show the main point for you to decide. But in the first step, I needed to make a choice for the mathematical target to plot. It could have been anyone. I chose the musical scale. -- The notes are logarithmic.
</div>
</details>

::: {.column-margin}
<a href="#1" onClick="statejs.notes.anim6(); cleandiv('divnotes2_t')">_</a>
:::

<script>var wslog2; //for .markFocused() , but that does not prevent the scrolling down to the last workspace</script>

<details>
<summary id="2">2</summary>
<div onClick="wslog2.markFocused();" id="blocklyDivLog2" style="height: 300px;"></div>
<script>
function v2() {
wslog2=brender("(:tiles/infix (* (log2 (:tiles/infix (/ x 220))) 7))", "blocklyDivLog2");
}
v2();
</script>
<div class="desc" id="blocklyDivLog2_t">
To make it fit the notes, you need to insert some scale factors into the logarithmic formula. -- But I have jumped ahead. I need to plot the plain log2 first.
</div>
</details>

::: {.column-margin}
<a href="#2" onClick="v2(); cleandiv('blocklyDivLog2_t')">_</a>
:::

::: {.hidden}
```{python}
#| output: asis
print("<script>")
with open('log23.cljs', 'r') as file:
    data = file.read().replace('\n', '')
print("scittle.core.eval_string('", data, "')")
print("</script>")
```
:::

<!--
::: {.column-margin}
<details>
<summary>--</summary>
<div id="divlog23" class="jxgbox" style="height:150px; width: 350px"></div>
<script>
statejs.log23.main("divlog23");
statejs.log23.anim2();
</script>
</details>
:::
-->

<details>
<summary id="5">3</summary>
<div id="blocklyDiv10" style="height: 150px; width: 800px"></div>
<script>brender("(plot log2 [1 2 4 8])", "blocklyDiv10")</script>
<div class="desc" id="blocklyDiv10_t">
And here, I hit the main message of my presentation. It is this. -- It is the log2 that you plot. This is so obvious that I repeat: It is the log2 that you plot. The log2 is a perfectly good mathematical object. It is not the log2 of x or y or z. It is just log2. You plot just log2. That, in a nutshell, is my approach for plotting.
</div>

```{python}
plot(log2, [1, 2, 4, 8])
```

<script>
var clean5 = () => { brender("(plot log2 [1 2 4 8])", "blocklyDiv10"); cleandiv("blocklyDiv10_t");}
</script>
</details>

::: {.column-margin}
<a href="#5" onClick=clean5()>_</a>
:::

<details>
<summary id="3">4</summary>
<div id="divmanylogs" class="jxgbox" style="height:300px"></div>
<script>
statejs.log23.many("divmanylogs");

const mywait = async () => {
  statejs.log23.manyanim2(110, 7);
  await delay(500);
  statejs.log23.manyanim2(440, 7);
  await delay(500);
  statejs.log23.manyanim2(880, 7);
};

var clean3 = () => {mywait(); cleandiv("divmanylogs_t")}
</script>

<span onClick=statejs.log23.many("divmanylogs") style="color:blue">A</span>
<span onClick=mywait() style="color:blue">B</span>
<div class="desc" id="divmanylogs_t">
While I do worry that I have not given my viewers enough time to digest this, I move on towards the practical goal. -- I need to get more to something like this.
</div>

</details>
::: {.column-margin}
<a href="#3" onClick=clean3()>_</a>
:::

<details>
<summary id="4">5</summary>
<div id="blocklyDiv5" style="height: 350px;"></div>
<script>
var ws5 = brender(" (:tiles/infix (* (log2 (:tiles/infix (/ x 220))) 7))", "blocklyDiv5");

var addBlocks = (ws) => (s) =>
Blockly.Xml.appendDomToWorkspace(Blockly.utils.xml.textToDom(parse(s)), ws);
var abws5 = addBlocks(ws5);
</script>


<span style="color:blue">A</span>
<span onClick="abws5('(Poe intersect steps x)'); abws5('(Poe intersect steps 440)'); abws5('(def :tiles/slot (return :tiles/slot))')" style="color:blue">B</span>

<div class="desc" id="blocklyDiv5_t">
To plot the notes, I come back to the formula I showed at the beginning. I arrived at this formula by trial and error. This formula is the result of my plots and mistakes, the digested essence. You cannot plot this formula directly, at least when using my approach. This is the main theme again. I need a proper mathematical target to plot. -B- To get such a target, I need to wrap this formula into a procedure. -- The procedure itself I gave the name Poe. It takes the arguments intersect, steps and the frequency x. -- The procedure returns the formula. -- You have to replace the numbers by the chosen names. -C- I provide the procedure as Python code.
</div>
</details>

<script>
var four_ = () => {
var ws4u = brender(" (def (Poe intersect steps x) (return (:tiles/infix (* (log2 (:tiles/infix (/ x intersect))) steps))))", "blocklyDiv5");
var abws4u = addBlocks(ws4u);
abws4u('(Poe 220 7 440)')
abws4u('(Poe 1 1 2)')
cleandiv("blocklyDiv5_t")
}
</script>

::: {.column-margin}
<a href="#4" onClick=four_()>_</a>
<details>
<summary>C</summary>
<div style="width: 300px">
```{python}
def Poe(intersect, steps, x):
    return log2(x/intersect) * steps

Poe(220, 7, 440)
```
</div>
</details>
:::


<!--
<details>
<summary>--</summary>
<div id="jjjobs">
<div class="cljs-editor-new"><pre>(do (defn add-blocks [s] (display-html (str "&lt;tiles&gt;" s "&lt;/tiles&gt;")) :tiles)

(add-blocks '(def (log2a intersect steps x) (return :tiles/slot))))
(add-blocks '(log2a 220 7 440))
(add-blocks '(log2a 1 1 2))</pre></div>
</div>
</details>

<script src="jsfiles/rigsomelight.com/assets/inline-edit/main.js"></script>

<script>
function mutationCallback(customFn, mutationsList, observer) {
      mutationsList.forEach((mutation) => {
        if (mutation.target.className == "cljs-html-display active" &&
            mutation.type == "childList") {
        customFn(mutation.target.childNodes[0].innerText);
        }
    });
}

const observer = new MutationObserver(mutationCallback.bind(null, addBlocks(ws5)));
const targetNode = document.getElementById("jjjobs");
const config = { attributes: true, childList: true, subtree: true };
observer.observe(targetNode, config);
</script>

-->

<!--
:::{.column-screen-left}
<details>
<summary>xx</summary>
<table>
<tr>
<td style="vertical-align: top">
<div id="blocklyDivLog21" style="height: 150px; width: 230px"></div>
<script>brender("(log2 x)", "blocklyDivLog21")</script>
</td>
<td>
<div id="divlog2x" class="jxgbox" style="height:300px; width: 800px"></div>
<script>
statejs.log23.log3("divlog2x");
</script>
<span onClick=statejs.log23.log3("divlog2x") style="color:blue">1</span>
<span onClick=statejs.log23.log3anim2() style="color:blue">2</span>
<span onClick=statejs.log23.log3anim3() style="color:blue">3</span>
</td>
</tr>
</table>
</details>
:::
-->

:::{.column-screen-left}
<details>
<summary id="6">6</summary>
<table><tr>
<td style="vertical-align: top">
<div style="width: 230px"><img src="jsfiles/xkcd_partial.jpg" style="horizontal-align: right"></img></div>
</td>
<td style="vertical-align: top">
<div id="blocklyDiv14" style="height: 400px; width: 800px"></div>
<script>
var r14= () => brender("(plot (partial Poe 220 7) [1 2 4 8])", "blocklyDiv14")
var ws6 = r14();
</script>

<span onClick="addBlocks(ws6)('(log2b intersect steps)'); addBlocks(ws6)('(log2b intersect steps)'); addBlocks(ws6)('(def :tiles/slot (return :tiles/slot))') " style="color:blue">D</span>


<div class="desc" id="blocklyDiv14_t">
The procedure named Poe is not yet the mathematical target. The procedure Poe which does the calculation according to the original formula shares the same fate as this formula: also Poe cannot be plotted directly. To make the desired mathematical target out of Poe, I need to use a standard maneuver of computer science. You take the partial of Poe. -- Here is my main theme in spades: "partial" taking a procedure to deliver the target to plot. Only now can you plot the scaled log2. -- All this can in turn be wrapped in a procedure. -- If all this is too much, maybe it helps that this notebook is online if you like to try yourself.
</div>
</td>
</tr></table>

</details>
:::

::: {.hidden}
```{python}
def log2b(intersect, steps):
    return partial(Poe, intersect, steps)
```
:::

::: {.column-margin}
<a href="#6" onClick="r14(); cleandiv('blocklyDiv14_t')">_</a>
<details>
<summary>A</summary>
<div style="width: 300px">
```{python}
plot(partial(Poe, 220, 7), [1, 2, 4, 8])
```
</div>
</details>

<details>
<summary>B</summary>
<div style="width: 300px">
```{python}
plot(log2b(220, 7), [1, 2, 4, 8])
```
</div>
</details>
:::

<details>
<summary id="9">7</summary>
<span onClick="" style="color:blue">A</span>
<span onClick="abws19('x1')" style="color:blue">x1</span>
<span onClick="abws19('0.7')" style="color:blue">0.7</span>
<div id="blocklyDiv19" style="height: 300px;"></div>
<script>
r19 = () => brenderT("(call (log2b 1 1) x0)", "blocklyDiv19", true);
var ws19 = r19();
var abws19 = addBlocks(ws19);
</script>

<div class="desc" id="blocklyDiv19_t">
Not only can log2b be plotted. Log2b can also be called. What might be surprising is that log2b can be called with a symbol. -- I chose x0 as the symbol in this example. -- But it is arbitrary. It could also have been x1. Remember that log2 does not know anything about x or y or z. --  Also, the step argument does not need to be an integer, it can well be 0 point 7.
</div>
</details>

<script>
var fu19 = () => {
var ws19_E = brenderT("(call (log2b 1 0.7) x1)", "blocklyDiv19", true);
var abws19_E = addBlocks(ws19_E);
// abws19_E('(call (log2b 1 1) x1)')
// abws19_E('(call (log2b 1 0.7) x1)')
}
</script>

::: {.column-margin}
<a href="#9" onClick="fu19(); cleandiv('blocklyDiv19_t');">_</a>
<details>
<summary>B</summary>
<div style="width: 300px">
```{python}
call(log2b(1, 1), x0)
```
</div>
</details>

<details>
<summary>C</summary>
<div style="width: 300px">
```{python}
call(log2b(1, 1), x1)
```
</div>
</details>

<details>
<summary>D</summary>
<div style="width: 300px">
```{python}
call(log2b(1, 0.7), x1)
```
</div>
</details>
:::

<details>
<summary id="11">8</summary>
<div id="divlogtri" class="jxgbox" style="height:300px;"></div>
<script>
statejs.strfrac1ovX = "$$\\frac{1}{x}$$";
statejs.log23.logtri("divlogtri");
</script>
<span onClick=statejs.log23.logtri("divlogtri") style="color:blue">A</span>
<span onClick="statejs.log23.trianim2()" style="color:blue">B</span>
<span onClick="statejs.log23.trianim3()" style="color:blue">C</span>
<span onClick="statejs.log23.trianim4()" style="color:blue">D</span>
<span onClick="statejs.log23.trianim5()" style="color:blue">E</span>
<span onClick="statejs.log23.trianim6()" style="color:blue">F</span>
<span onClick="statejs.log23.trianim7()" style="color:blue">G</span>
<div class="desc" id="divlogtri_t">
In fact, the case 0.7 is almost a special one. -- As any curve, it can be approximated by triangles. -- I move the triangles to the ground level. -- Now the curve known as "one over x" fits their hights quite nicely. -- You can also try the other way around -- That does not work quite as well. -- The trick is to shrink the area of the triangle while retaining its shape.
</div>
</details>

::: {.column-margin}
<a href="#11" onClick="cleandiv('divlogtri_t');">_</a>
:::

<details>
<summary id="12">9</summary>
<div id="blocklyDiv17a" style="height:150px"></div>
<script>var ws17a = brender("(call (log2b 1 0.7) x0)", "blocklyDiv17a")
var ab = addBlocks(ws17a);
</script>
<span onClick="ab('(D :tiles/slot)')" style="color:blue">D</span>
<div class="desc" id="blocklyDiv17a_t">
This triangle business smells of derivatives. -- Taking the derivate is simple and easy.
</div>
</details>

::: {.column-margin}
<a href="#12" onClick="brender('(call (D (log2b 1 0.7)) x0)', 'blocklyDiv17a'); cleandiv('blocklyDiv17a_t');">_</a>
:::

<details>
<summary id="13">10</summary>
```{python}
call(D(log2b(1, 0.7)), x0).evalf()
```

<div id="blocklyDiv22a" style="height:100px"></div>
<script>
var r13 = () => brender("(call (D ln) x0)", "blocklyDiv22a");
r13();
</script>
```{python}
call(D(ln), x0)
```
<div class="desc" id="blocklyDiv22a_t">
If I do the actual calculation with 0.7, I nearly get one over x for the derivative. To get the exact result, I need to switch to the natural logarithm ln.
</div>
</details>

::: {.column-margin}
<a href="#blocklyDiv22a" onClick="r13(); cleandiv('blocklyDiv22a_t');">_</a>
:::

<details>
<summary id="14">--</summary>
$$\Large \left. \frac{d \ln(x)}{dx} \right|_{x=x_0}$$
<div class="desc" id="tex14_t">
The usual mathematical notation for the derivative at point x0 is by unsing the vertical bar, colloquially called pipe.
</div>
</details>

::: {.column-margin}
<a href="#blocklyDiv22a" onClick="cleandiv('tex14_t');">_</a>
:::

<details>
<summary id="15">--</summary>
<div id="blocklyDivpipe" style="height:100px"></div>
<script>
var r15 = () => brender("((D ln) x0)", "blocklyDivpipe");
r15();
</script>

```{python}
(D(ln) | x0)
```
<div class="desc" id="blocklyDivpipe_t">
In my pictorial representation, I'd like to do the same. Note that it is not the D procedure that is representd by the pipe symbol. It is the call procedure that is dropped and replaced by the pipe.
</div>
</details>

::: {.column-margin}
<a href="#15" onClick="r15(); cleandiv('blocklyDivpipe_t');">_</a>
:::

<details>
<summary id="16">11</summary>
<div id="blocklyDivpipe2" style="height:100px"></div>
<script>
var r16 = () => brender("((log2b 220 7) 440)", "blocklyDivpipe2");
r16();
</script>

```{python}
(log2b(220, 7) | 440)
```
<div class="desc" id="blocklyDivpipe2_t">
All this means that also a direct call to log2b can be done with a pipe. -- You might think that such a custom pipe is a lot of work. This is not so. My custom pipe is just a few lines of Python.
</div>
</details>

::: {.column-margin}
<a href="#16" onClick="r16(); cleandiv('blocklyDivpipe2_t');">_</a>

<details>
<summary>A</summary>
<div style="width: 300px">
```{python}
#| eval: false
class PipeAsCall(object):
    def __init__(self, func):
        self.func = func
    def __or__(self, other):
        return self.func(other)
    def __call__(self, x):
        return self.func(x)

def partial(*args):
    return PipeAsCall(
        functools.partial(*args))
```
</div>
</details>
:::

<script>
document.querySelectorAll("details")
.forEach(d => d.setAttribute("open", ""))
</script>