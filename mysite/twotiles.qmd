---
title: "Twotiles Code Visualization"
format:
  html:
    code-fold: true
    code-summary: " "
    echo: true
    self-contained: false
jupyter: python3
execute:
  cache: true
---

<script type="text/javascript" charset="UTF-8"
 src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />

<script src="https://cdn.jsdelivr.net/npm/scittle@0.6.22/dist/scittle.js"></script>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script src="https://unpkg.com/blockly/msg/en.js"></script>
<script src="https://kloimhardt.github.io/twotiles/twotiles_core.js"></script>

<script>
var parse = scittle.core.eval_string(twotiles.parse_clj);
Blockly.defineBlocksWithJsonArray(twotiles.blocks);
</script>

<script>
var brender = (code,divid) =>
Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.utils.xml.textToDom(parse(code)),
Blockly.inject(divid,
{"toolbox": twotiles.toolbox,
"sounds": false,
"scrollbars": false,
"trashcan": false}));
</script>

<script>var statejs = {};</script>

Twotiles is a free and open JavaScript libaray for turning code into visual blocks. The library can be used in any website.

## Example

```{python}
#| output: asis

import numpy as np
import json

# https://muted.io/note-frequencies/
data = np.genfromtxt('notes.txt', delimiter='\t', dtype=str)
row_names = data[:, 0].tolist()
numerical_data = np.matrix.transpose(data[:, 1:]).astype(float).tolist()
               
print("<script>")
print("statejs['notenames']= ")
print(json.dumps(row_names))
print("statejs['frequencies']= ")

nofreq = [item
    for subl in
      [list(map(lambda n,f: [n, idx, f], row_names, fs))
        for idx, fs in enumerate(numerical_data)]
   for item in subl]


print(json.dumps([[nf[0] + str(nf[1]), nf[2]] for nf in nofreq if not nf[0].endswith("s")]))
print("</script>")
```

<div id="divnotes" class="jxgbox" style="width:750px; height:300px;"></div>
<script src="myjs/notes.js"></script>
<script>
notes.main("divnotes");
</script>

<span onClick="notes.anim1()" style="color:blue">1</span>

 ```{ojs}
332
 notes.out();
 ```

The following uses a simple math example, taking the derivative of a logarithm, to show how code is visualized with the Twotiles library.

### Symbolic computation in Python: SymPy

```{python}
#| code-summary: "Code Preamble"
from sympy import symbols,diff,log
from functools import partial
x=symbols("x")
b=symbols("b")
y=symbols("y")

def call(f, x):
    return f(x)
```

Using SymPy, one can calculate with symbols. Here, `x` is a symbol.

<div id="blocklyDiv21" style="height: 100px;"></div>
<script>brender("(:tiles/infix (- (:tiles/infix (/ 5 x)) (:tiles/infix (+ 50 14))))", "blocklyDiv21")</script>
```{python}
5/x - (50 + 14)
```
<div id="jxg10" class="jxgbox" style="width:750px; height:300px;"></div>

<script>
statejs['board1'] = JXG.JSXGraph.initBoard('jxg10', {
            boundingbox: [-20, -54, 20, -74],
            axis:true
        });
statejs['board1'].create('functiongraph', ['5/x - (50 + 14)'], {strokeColor:'red'});
</script>

<p></p>

<div id="blocklyDivLog" style="height: 100px;"></div>
<script>brender("(log x)", "blocklyDivLog")</script>

<div id="jxgLog" class="jxgbox" style="width:750px; height:300px;"></div>

<script>
statejs['board3'] = JXG.JSXGraph.initBoard('jxgLog', {
            boundingbox: [-5, 10, 70, -10],
            axis:true
        });
statejs['board3'].create('functiongraph', ['log(x)']);
statejs['board3'].create('line',[[64,0],[64,4.16]], {straightFirst:false, straightLast:false, strokeWidth:5, strokeColor:'#00ff00'});
</script>

<div id="blocklyDiv1" style="height: 100px;"></div>
<script>brender("(log 64)", "blocklyDiv1")</script>
```{python}
log(64.0)
```

One can also make an explicit call to the `log` function.

<div id="blocklyDiv23" style="height: 100px;"></div>
<script>brender("(call log 64)", "blocklyDiv23")</script>
```{python}
call(log, 64.0)
```

This makes `call` a special kind of function. Because it takes a function as its first argument, `call` is a function of "higher order". But for now we return to the usual way of making a calculation.

<div id="blocklyDiv2" style="height: 100px;"></div>
<script>brender("(diff (log x) x)", "blocklyDiv2")</script>
```{python}
diff(log(x),x)
```

<div id="jxgOx" class="jxgbox" style="width:750px; height:300px;"></div>

<script>
var range = (n) => [...Array(n).keys()];

var points = (nmax, o, f) =>
 range(nmax).map((n) =>
  [[String(n) + "_1", [n+o, 0]], [String(n) + "_2", [n+o+1, 0]], [String(n) + "_3", [n+o+1, f(n+o+1)]]]);

function triangle() {
let b2 = statejs["board2"]
let ps = statejs["points"]

ps.map((tri) => {
       b2.create('point',tri[0][1], {name:tri[0][0]}).setLabel("")
       b2.create('point',tri[1][1], {name:tri[1][0], visible: false})
       b2.create('point',tri[2][1], {name:tri[2][0], visible: false})
})

ps.map((tri) => b2.create('polygon',[tri[0][0], tri[1][0], tri[2][0]], { borders:{strokeColor:'black'}}))

ps.map((tri) => {
b2.create('transform',
  [function(){return b2.select(tri[2][0]).X()-tri[2][1][0];},
   function(){return b2.select(tri[2][0]).Y()-tri[2][1][1];}],
   {type:'translate'})
   .bindTo([b2.select(tri[0][0]),b2.select(tri[1][0])]);
})
}

function anim(n) {
let tri = statejs["points"][n];
 statejs['board2'].select(tri[2][0])
   .moveTo([tri[2][1][0], Math.log(tri[2][1][0])],1500)
}

function shrink() {
let tri = statejs["points"][0];
let hohe = tri[2][1][1] -  tri[1][1][1];
let faktor = 0.5;
let p1 = statejs['board2'].select(tri[0][0]);
let p2 = statejs['board2'].select(tri[1][0]);
p1.moveTo([p1.X() + faktor, p1.Y() + faktor * hohe], 1500);
p2.moveTo([p2.X(), p2.Y() + faktor * hohe], 1500);
}

</script>

<script>
statejs["board2"] = JXG.JSXGraph.initBoard('jxgOx', {
            boundingbox: [-3, 2, 7, -2],
            axis:true
        });

statejs["board2"].create('functiongraph', ['log(x)']);
statejs["board2"].create('functiongraph', ['1 / x'], {strokeColor:'red'});
statejs["points"] = points(6, 0, (x) => 1 / x).filter((_, index) => index % 2 === 0);
</script>

<span onClick="triangle()" style="color:blue">t</span>
<span onClick="anim(0)" style="color:blue">1</span>
<span onClick="anim(1)" style="color:blue">2</span>
<span onClick="anim(2)" style="color:blue">3</span>
<span onClick="shrink()" style="color:blue">s</span>

All of our natural science is based on those triangles. Choosing the position and size of the triangles is the art of the scientist. But the shape of those trianges seems to be universally given by nature.

<div id="blocklyDiv3" style="height: 150px;"></div>
<script>brender("(def (logarithm b x) (return (:tiles/infix (/ (log x) (log b)))))", "blocklyDiv3")</script>
```{python}
def logarithm(b, x):
    return log(x) / log(b)
```

<div id="blocklyDiv4" style="height: 100px;"></div>
<script>brender("(logarithm 8.0 64.0)", "blocklyDiv4")</script>
```{python}
logarithm(8.0, 64.0)
```

<div id="blocklyDiv5" style="height: 150px;"></div>
<script>brender("(def (log_base b) (return (partial logarithm b)))", "blocklyDiv5")</script>
```{python}
def log_base(b):
    return partial(logarithm, b)
```

<div id="blocklyDiv6" style="height: 100px;"></div>
<script>brender("(call (log_base 8.0) 64.0)", "blocklyDiv6")</script>
```{python}
call(log_base(8.0),64.0)
```

<div id="blocklyDiv7" style="height: 100px;"></div>
<script>brender("(diff (call (log_base 8.0) x) x)", "blocklyDiv7")</script>
```{python}
diff(call(log_base(8.0),x),x)
```
### Symbolic computation in JavaScript: EmmyJS

<script src="https://kloimhardt.github.io/blog/js/emmy.js/build/emmy_bundle.js"></script>

<script>
var loadEnv = (name) => window[name] = emmy[name];
["div", "mul", "sub", "add", "expt", "log",
"partial", "symbol", "to_infix"].map(loadEnv);
</script>

<script>
var x = symbol("x");
var b = symbol("b")
var y = symbol("y")
var call = (f, x) => f(x);

var diff = emmy.D;
var logarithm = (b,x) => div(log(x),log(b));
var log_base = (b) => partial(logarithm,b);

</script>

<div id="blocklyDiv8" style="height: 100px;"></div>
<script>brender("(call (diff (log_base 8.0)) x)", "blocklyDiv8")</script>
```{ojs}
to_infix(
  call(diff(log_base(8.0)), x)
)
```

<div id="blocklyDiv9" style="height: 100px;"></div>
<script>brender("(call (diff log) x)", "blocklyDiv9")</script>
```{ojs}
//| output: asis
to_infix(
  call(diff(log), x)
)
```

### SymPy Recap

<div id="blocklyDiv10" style="height: 100px;"></div>
<script>brender("(diff (log x) x)", "blocklyDiv10")</script>

## Guide

### Using Twotiles in a Website

To display graphical blocks, include into your web-site the Scittle, Blockly and indeed the Twotiles library:

```
<script src="https://cdn.jsdelivr.net/npm/scittle@0.6.22/dist/scittle.js"></script>
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script src="https://unpkg.com/blockly/msg/en.js"></script>
<script src="https://kloimhardt.github.io/twotiles/twotiles_core.js"></script>
```

Then initialize the Twotiles parser ...

```
<script>
var parse = scittle.core.eval_string(twotiles.parse_clj);
</script>
```
... and Blockly:

```
<script>
Blockly.defineBlocksWithJsonArray(twotiles.blocks);
</script>
```

It is convenient to have a render function:

```
<script>
var brender = (code,divid) =>
Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.utils.xml.textToDom(parse(code)),
Blockly.inject(divid,
{"toolbox": twotiles.toolbox,
"sounds": false,
"scrollbars": false,
"trashcan": false}));
</script>
```

Then graphics can be displayed with

```
<div id="blocklyDiv" style="height: 100px;"></div>
<script>brender("(log 64)", "blocklyDiv")</script>
```
which looks like this:

<div id="blocklyDiv" style="height: 100px;"></div>
<script>brender("(log 64)", "blocklyDiv")</script>

### Using EmmyJS

A detailed example of EmmyJS can be found at [sicmutils-as-js-book-part1.html](https://kloimhardt.github.io/blog/html/sicmutils-as-js-book-part1.html)

### Quarto Notebook of this Page

This page was generated with Quarto out of the file [twotiles.qmd](https://github.com/kloimhardt/site/blob/main/mysite/twotiles.qmd)

