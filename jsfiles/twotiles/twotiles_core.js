var twotiles = {"parse_clj":"(ns twotiles)\n\n(defmulti gen (fn [m _] (:type m)))\n\n(defmethod gen :slot [] nil)\n\n(defn blockmap [type givenid & [inline?]]\n  (cond-> {:type type :id (str type givenid)}\n    (some? inline?) (assoc :inline (str inline?))))\n\n(defmethod gen :num [{:keys [nummer]} givenid]\n  [:block (blockmap \"num\" givenid)\n   [:field {:name \"nummer\"} nummer]])\n\n(defmethod gen :text [{:keys [dertext]} givenid]\n  [:block (blockmap \"text\" givenid)\n   [:field {:name \"dertext\"} dertext]])\n\n;; is really a vector\n(defmethod gen :args [{:keys [argsvec inline?]} givenid]\n  (let [xml-block-type      (str \"args-\" (count argsvec))\n        {:keys [id] :as bm} (blockmap xml-block-type givenid inline?)]\n    (into [:block bm]\n          (map-indexed (fn [idx v]\n                         [:value {:name (str \"arg_\" (+ idx 1))}\n                          (gen v (str (+ idx 1) \"-\" id))]) argsvec))))\n\n(defmethod gen :list [{:keys [argsvec inline?]} givenid]\n  (let [xml-block-type      (str \"list-h-\" (count argsvec))\n        {:keys [id] :as bm} (blockmap xml-block-type givenid inline?)]\n    (into [:block bm]\n          (map-indexed (fn [idx v]\n                         [:value {:name (str \"args-\" (+ idx 1))}\n                          (gen v (str (+ idx 1) \"-\" id))]) argsvec))))\n\n\n(defmethod gen :fun [{:keys [kopf argsvec subtype inline?]} givenid]\n  (let [xml-block-type      (str subtype \"-\" (inc (count argsvec)) \"-inp\")\n        {:keys [id] :as bm} (blockmap xml-block-type givenid inline?)]\n    (into [:block bm\n           [:field {:name \"kopf\"} kopf]]\n          (map-indexed (fn [idx v]\n                         [:value {:name (str \"args-\" (+ idx 2))}\n                          (gen v (str (+ idx 2) \"-\" id))]) argsvec))))\n\n(defn rearrange [m]\n  (let [a (partition 2 m)]\n    (concat (map first a) (map second a))))\n\n(defmethod gen :map [{:keys [argsvec subtype inline?]} givenid]\n  (let [xml-block-type      (str subtype \"-\" (* (count argsvec) 2) \"-inp\")\n        {:keys [id] :as bm} (blockmap xml-block-type givenid inline?)]\n    (into [:block bm]\n          (rearrange ;;(rearrange [1 2 3 4]) => (1 3 2 4)\n            ;;the Blockly ui does this rearrangemnt to the XML and\n            ;;the end->code/parse depends on it\n            ;;namely that in the XML all the :field are given first and\n            ;;then the :value\n            (apply concat\n                   (map-indexed (fn [idx v]\n                                  (let [i (inc (* idx 2))]\n                                    [[:field {:name (str \"key-\" i)}\n                                      (str (first v))]\n                                     [:value {:name (str \"val-\" (inc i))}\n                                      (gen (second v) (str (inc i) \"-\" id))]]))\n                                argsvec))))))\n\n\n(defn addcoords [block [x y]]\n  (update block 1 #(-> %\n                       (assoc :x x)\n                       (assoc :y y))))\n\n(defn gen-str [[x y]]\n  (str \"-\" x \"-\" y))\n\n(defn page [coords & blocks]\n  (->> blocks\n       (map-indexed (fn [idx blk] (addcoords (gen blk (gen-str (coords idx)))\n                                             (coords idx))))\n       (into [:xml])\n       ;;html\n       ))\n\n(def slot {:type :slot})\n\n(defn num [nummer]\n  {:type :num :nummer nummer})\n\n(defn kw [k]\n  {:type :num :nummer (str k)})\n\n(defn text [txt]\n  {:type :text :dertext txt})\n\n(defn tiles-deref [e]\n  {:type :num :nummer (str \"@\" e)})\n\n(defn fun [name & argsvec]\n  {:type :fun :subtype \"funs-h\" :kopf name :argsvec argsvec})\n\n(defn fun-infi [name & argsvec]\n  (assoc (apply fun name argsvec) :subtype \"infi-h\"))\n\n(defn args [& argsvec]\n  {:type :args :argsvec argsvec})\n\n(defn lst [& argsvec]\n  {:type :list :argsvec argsvec})\n\n(defn t-map [& argsvec]\n  (if (> (count argsvec) 1)\n    {:type :map :subtype \"map-h\" :argsvec argsvec}\n    (text \"clj-tiles error: one-entry map not allowed\")))\n\n(defn chapter [& pages] (into [] pages))\n\n(defn exp [v]\n  (if (vector? v)\n    (let [erst (first v)\n          appl (fn [fuct] (apply fuct erst (map exp (into [] (rest v)))))]\n      (cond\n        (and (= (count v) 3) (#{\"/\" \"+\" \"*\" \"-\"} erst)) (appl fun-infi)\n        (#{\"def\" \"defn\" \"do\"} erst)                     (assoc (appl fun) :inline? false)\n        :else                                           (appl fun)))\n    (cond\n      (map? v)    v\n      (nil? v)    (num \"nil\")\n      (string? v) (text v)\n      :else       (num v))))\n\n(defn infix-sensible? [lst]\n  (when (and (list? lst) (= (count lst) 3))\n    (let [[f s t] lst]\n      (and  (#{\"/\" \"+\" \"*\" \"-\"} (str f))\n            (or (symbol? s) (number? s) (infix-sensible? s))\n            (or (symbol? t) (number? t) (infix-sensible? t))))))\n\n(defn parse [l]\n  (cond\n    (list? l)\n    (let [erst (str (first l))\n          appl (fn [fuct] (apply fuct erst (map parse (rest l))))]\n      (cond\n        (or (list? (first l)) (= \":tiles/slot\" erst)) (apply lst (map parse l))\n        (= \":tiles/vert\" erst)                        (assoc (parse (second l)) :inline? false)\n        (= \":tiles/keep\" erst)                        (parse (second l))\n        (= \":tiles/num\" erst)                         (num (second l))\n        (= \"clojure.core/deref\" erst)                 (tiles-deref (second l))\n        (= \"quote\" erst)                              (num (str \"'\" (second l)))\n        ;;(infix-sensible? l) (appl fun-infi) ;;detect infix automatically for simple expressions\n        (= \":tiles/infix\" erst)                       (assoc (parse (second l)) :subtype \"infi-h\")\n        (#{\"def\" \"defn\" \"do\"} erst)                   (assoc (appl fun) :inline? false)\n        :else                                         (appl fun)))\n    (vector? l)\n    (if (empty? l)\n      (num \"[ ]\")\n      (apply args (map parse l)))\n    (map? l)\n    (cond\n      (empty? l)\n      (num \"{ }\")\n      (:tiles/numslot l)\n      slot\n      :else\n      (apply t-map (map (fn [[k v]] [k (parse v)]) l)))\n    (and (set? l) (empty? l))\n    (num \"#{ }\")\n    (= :tiles/slot l) slot\n    (nil? l)          (num \"nil\")\n    (string? l)       (text l)\n    (keyword? l)      (kw l)\n    :else             (num l)))\n\n(defn shift-coords [nofblocks & coords]\n  (->> (range 0 nofblocks)\n       (mapv (fn [x] [0 (* 50 x)]))\n       (concat coords)\n       (mapv (fn [[x y]] [(+ x 10) (+ y 10)]))))\n\n(defn p-gen [parser-fn]\n  (fn [coords & blocks]\n    (let [shifted (apply shift-coords (count blocks) coords)]\n      (->> blocks\n           (map-indexed (fn [idx blk]\n                          (addcoords (gen (parser-fn blk) (gen-str (shifted idx)))\n                                     (shifted idx))))\n           (into [:xml])\n           ;;html\n           ))))\n\n(def pg (p-gen exp))\n(def rpg (p-gen parse))\n\n(defn my-walk\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form) form\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))\n\n(defn my-postwalk\n  [f form]\n  (my-walk (partial my-postwalk f) f form))\n\n(defn my-html-map [d]\n  (clojure.string/trimr\n    (apply str\n           (map (fn [[k v]] (str (name k) \"=\\\"\" v \"\\\" \"))\n                (into (sorted-map) d)))))\n\n(defn my-html-vec [d]\n  (cond\n    (vector? d)\n    (if (map? (second d))\n      (str \"<\" (name (first d)) \" \" (my-html-map (second d)) \">\"\n           (apply str (rest (rest d)))\n           \"<\" \"/\" (name (first  d)) \">\")\n      (str \"<\" (name (first d)) \">\"\n           (apply str (rest d))\n           \"<\" \"/\" (name (first  d)) \">\"))\n    :else d))\n\n(defn my-html [d] (my-postwalk my-html-vec d))\n\n(defn twotiles-xml [code]\n  (my-html (rpg [[0 0]] (read-string code))))\n\ntwotiles-xml\n","toolbox":{"kind":"categoryToolbox","contents":[{"kind":"category","name":"â‹®","contents":[{"kind":"block","type":"num"},{"kind":"block","type":"funs-h-2-inp"},{"kind":"block","type":"funs-h-3-inp"}]}]},"blocks":[{"type":"num","message0":"%1","args0":[{"type":"field_input","name":"nummer"}],"inputsInline":true,"output":null,"colour":"#A65C81"},{"type":"text","message0":"\" %1 \"","args0":[{"type":"field_input","name":"dertext"}],"inputsInline":true,"output":null,"colour":"#A65C81"},{"type":"funs-h-2-inp","message0":"%1 %2","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"}],"inputsInline":true,"output":null,"colour":270},{"type":"funs-h-3-inp","message0":"%1 %2 %3","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"},{"type":"input_value","name":"args-3"}],"inputsInline":true,"output":null,"colour":140},{"type":"funs-h-4-inp","message0":"%1 %2 %3 %4","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"},{"type":"input_value","name":"args-3"},{"type":"input_value","name":"args-4"}],"inputsInline":true,"output":null,"colour":230},{"type":"funs-h-5-inp","message0":"%1 %2 %3 %4 %5","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"},{"type":"input_value","name":"args-3"},{"type":"input_value","name":"args-4"},{"type":"input_value","name":"args-5"}],"inputsInline":true,"output":null,"colour":360},{"type":"funs-h-6-inp","message0":"%1 %2 %3 %4 %5 %6","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"},{"type":"input_value","name":"args-3"},{"type":"input_value","name":"args-4"},{"type":"input_value","name":"args-5"},{"type":"input_value","name":"args-6"}],"inputsInline":true,"output":null,"colour":"#A65C81"},{"type":"funs-h-7-inp","message0":"%1 %2 %3 %4 %5 %6 %7","args0":[{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-2"},{"type":"input_value","name":"args-3"},{"type":"input_value","name":"args-4"},{"type":"input_value","name":"args-5"},{"type":"input_value","name":"args-6"},{"type":"input_value","name":"args-7"}],"inputsInline":true,"output":null,"colour":140},{"type":"args-1","message0":"%1","args0":[{"type":"input_value","name":"arg_1"}],"inputsInline":true,"output":null,"colour":270},{"type":"args-2","message0":"%1 %2","args0":[{"type":"input_value","name":"arg_1"},{"type":"input_value","name":"arg_2"}],"inputsInline":true,"output":null,"colour":140},{"type":"args-3","message0":"%1 %2 %3","args0":[{"type":"input_value","name":"arg_1"},{"type":"input_value","name":"arg_2"},{"type":"input_value","name":"arg_3"}],"inputsInline":true,"output":null,"colour":230},{"type":"args-4","message0":"%1 %2 %3 %4","args0":[{"type":"input_value","name":"arg_1"},{"type":"input_value","name":"arg_2"},{"type":"input_value","name":"arg_3"},{"type":"input_value","name":"arg_4"}],"inputsInline":true,"output":null,"colour":360},{"type":"args-5","message0":"%1 %2 %3 %4 %5","args0":[{"type":"input_value","name":"arg_1"},{"type":"input_value","name":"arg_2"},{"type":"input_value","name":"arg_3"},{"type":"input_value","name":"arg_4"},{"type":"input_value","name":"arg_5"}],"inputsInline":true,"output":null,"colour":"#A65C81"},{"type":"args-6","message0":"%1 %2 %3 %4 %5 %6","args0":[{"type":"input_value","name":"arg_1"},{"type":"input_value","name":"arg_2"},{"type":"input_value","name":"arg_3"},{"type":"input_value","name":"arg_4"},{"type":"input_value","name":"arg_5"},{"type":"input_value","name":"arg_6"}],"inputsInline":true,"output":null,"colour":140},{"type":"list-h-2","message0":"%1 | %2","args0":[{"type":"input_value","name":"args-1"},{"type":"input_value","name":"args-2"}],"inputsInline":true,"output":null,"colour":70},{"type":"infi-h-3-inp","message0":"%1 %2 %3","args0":[{"type":"input_value","name":"args-2"},{"type":"field_input","name":"kopf"},{"type":"input_value","name":"args-3"}],"inputsInline":true,"output":null,"colour":140}]}